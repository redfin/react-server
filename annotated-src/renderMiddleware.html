<!DOCTYPE html>

<html>
<head>
  <title>renderMiddleware.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page_wrapper">
            <div id="jump_page">
              
                
                <a class="source" href="ClientController.html">
                  ClientController.js
                </a>
              
                
                <a class="source" href="ClientController.html">
                  ClientController.js
                </a>
              
                
                <a class="source" href="ClientRequest.html">
                  ClientRequest.js
                </a>
              
                
                <a class="source" href="ClientRequest.html">
                  ClientRequest.js
                </a>
              
                
                <a class="source" href="ExpressServerRequest.html">
                  ExpressServerRequest.js
                </a>
              
                
                <a class="source" href="ExpressServerRequest.html">
                  ExpressServerRequest.js
                </a>
              
                
                <a class="source" href="FramebackController.html">
                  FramebackController.js
                </a>
              
                
                <a class="source" href="FramebackController.html">
                  FramebackController.js
                </a>
              
                
                <a class="source" href="ReactServerAgent.html">
                  ReactServerAgent.js
                </a>
              
                
                <a class="source" href="ReactServerAgent.html">
                  ReactServerAgent.js
                </a>
              
                
                <a class="source" href="Cache.html">
                  Cache.js
                </a>
              
                
                <a class="source" href="Plugins.html">
                  Plugins.js
                </a>
              
                
                <a class="source" href="Request.html">
                  Request.js
                </a>
              
                
                <a class="source" href="ReactServerAgentSpec.html">
                  ReactServerAgentSpec.js
                </a>
              
                
                <a class="source" href="util.html">
                  util.js
                </a>
              
                
                <a class="source" href="client.html">
                  client.js
                </a>
              
                
                <a class="source" href="client.html">
                  client.js
                </a>
              
                
                <a class="source" href="common.html">
                  common.js
                </a>
              
                
                <a class="source" href="common.html">
                  common.js
                </a>
              
                
                <a class="source" href="History.html">
                  History.js
                </a>
              
                
                <a class="source" href="RootContainer.html">
                  RootContainer.js
                </a>
              
                
                <a class="source" href="RootElement.html">
                  RootElement.js
                </a>
              
                
                <a class="source" href="TheFold.html">
                  TheFold.js
                </a>
              
                
                <a class="source" href="FragmentDataCacheSpec.html">
                  FragmentDataCacheSpec.js
                </a>
              
                
                <a class="source" href="config.html">
                  config.js
                </a>
              
                
                <a class="source" href="config.html">
                  config.js
                </a>
              
                
                <a class="source" href="constants.html">
                  constants.js
                </a>
              
                
                <a class="source" href="constants.html">
                  constants.js
                </a>
              
                
                <a class="source" href="Navigator.html">
                  Navigator.js
                </a>
              
                
                <a class="source" href="RequestContext.html">
                  RequestContext.js
                </a>
              
                
                <a class="source" href="logging.html">
                  logging.js
                </a>
              
                
                <a class="source" href="logging.html">
                  logging.js
                </a>
              
                
                <a class="source" href="client.html">
                  client.js
                </a>
              
                
                <a class="source" href="common.html">
                  common.js
                </a>
              
                
                <a class="source" href="server.html">
                  server.js
                </a>
              
                
                <a class="source" href="stats.html">
                  stats.js
                </a>
              
                
                <a class="source" href="renderMiddleware.html">
                  renderMiddleware.js
                </a>
              
                
                <a class="source" href="renderMiddleware.html">
                  renderMiddleware.js
                </a>
              
                
                <a class="source" href="server.html">
                  server.js
                </a>
              
                
                <a class="source" href="server.html">
                  server.js
                </a>
              
                
                <a class="source" href="reactServerAgentSupport.html">
                  reactServerAgentSupport.js
                </a>
              
                
                <a class="source" href="ClientCssHelper.html">
                  ClientCssHelper.js
                </a>
              
                
                <a class="source" href="LABString.html">
                  LABString.js
                </a>
              
                
                <a class="source" href="PageUtil.html">
                  PageUtil.js
                </a>
              
                
                <a class="source" href="RequestLocalStorage.html">
                  RequestLocalStorage.js
                </a>
              
                
                <a class="source" href="StringEscapeUtil.html">
                  StringEscapeUtil.js
                </a>
              
                
                <a class="source" href="bundleNameUtil.html">
                  bundleNameUtil.js
                </a>
              
                
                <a class="source" href="navigateTo.html">
                  navigateTo.js
                </a>
              
            </div>
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>renderMiddleware.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-keyword">var</span> logger = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./logging'</span>).getLogger(__LOGGER__),
	React = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react'</span>),
	ReactDOMServer = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-dom/server'</span>),
	MobileDetect = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mobile-detect'</span>),
	RequestContext = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./context/RequestContext'</span>),
	RequestLocalStorage = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./util/RequestLocalStorage'</span>),
	RLS = RequestLocalStorage.getNamespace(),
	LABString = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./util/LABString'</span>),
	Q = <span class="hljs-built_in">require</span>(<span class="hljs-string">'q'</span>),
	config = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./config'</span>),
	ExpressServerRequest = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./ExpressServerRequest"</span>),
	expressState = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express-state'</span>),
	cookieParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">'cookie-parser'</span>),
	PageUtil = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./util/PageUtil'</span>),
	ReactServerAgent = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./ReactServerAgent'</span>),
	StringEscapeUtil = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./util/StringEscapeUtil'</span>),
	{getRootElementAttributes} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./components/RootElement'</span>),
	{PAGE_CSS_NODE_ID, PAGE_LINK_NODE_ID, PAGE_CONTENT_NODE_ID, PAGE_CONTAINER_NODE_ID} = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./constants'</span>);

<span class="hljs-keyword">var</span> _ = {
	map: <span class="hljs-built_in">require</span>(<span class="hljs-string">'lodash/map'</span>),
};</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>TODO FIXME ??
It <em>might</em> be worthwhile to get rid of all the closure-y things in render()
<a href="https://developers.google.com/speed/articles/optimizing-javascript">https://developers.google.com/speed/articles/optimizing-javascript</a></p>

            </div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>If an element hasn’t rendered in this long it gets the axe.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> FAILSAFE_RENDER_TIMEOUT = <span class="hljs-number">20e3</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>If a page’s <code>handleRoute</code> fails to resolve this fast it gets the axe.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> FAILSAFE_ROUTER_TIMEOUT = <span class="hljs-number">20e3</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>We’ll use this for keeping track of request concurrency per worker.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> ACTIVE_REQUESTS = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Some non-content items that can live in the elements array.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">var</span> ELEMENT_PENDING         = <span class="hljs-number">-1</span>;
<span class="hljs-keyword">var</span> ELEMENT_ALREADY_WRITTEN = <span class="hljs-number">-2</span>;

<span class="hljs-comment">/**
 * renderMiddleware entrypoint. Called by express for every request.
 */</span>
<span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">server, routes</span>) </span>{

	expressState.extend(server);</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>parse cookies into req.cookies property</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	server.use(cookieParser());</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>sets the namespace that data will be exposed into client-side
TODO: express-state doesn’t do much for us until we’re using a templating library</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	server.set(<span class="hljs-string">'state namespace'</span>, <span class="hljs-string">'__reactServerState'</span>);

	server.use((req, res, next) =&gt; { RequestLocalStorage.startRequest(() =&gt; {
		ACTIVE_REQUESTS++;

		<span class="hljs-keyword">var</span> start = RLS().startTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
		<span class="hljs-keyword">var</span> startHR = process.hrtime();

		logger.debug(<span class="hljs-string">`Incoming request for <span class="hljs-subst">${req.path}</span>`</span>);

		initResponseCompletePromise(res);</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>monkey-patch <code>res.write</code> so that we don’t try to write to the stream if it’s
already closed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> origWrite = res.write;
		res.write = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
			<span class="hljs-keyword">if</span> (!res.finished) {
				origWrite.apply(res, <span class="hljs-built_in">arguments</span>);
			} <span class="hljs-keyword">else</span> {
				logger.error(<span class="hljs-string">"Attempted write after response finished"</span>, { path: req &amp;&amp; req.path || <span class="hljs-string">"unknown"</span>, stack: logger.stack() });
			}
		};</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>TODO? pull this context building into its own middleware</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> context = <span class="hljs-keyword">new</span> RequestContext.Builder()
				.setRoutes(routes)
				.setDefaultXhrHeadersFromRequest(req)
				.create({</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>TODO: context opts?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				});</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Need this stuff in corvair for logging.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		context.setServerStash({ req, res, start, startHR });

		context.setMobileDetect(<span class="hljs-keyword">new</span> MobileDetect(req.get(<span class="hljs-string">'user-agent'</span>)));</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>setup navigation handler (TODO: should we have a ‘once’ version?)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		context.onNavigate( (err, page) =&gt; {

			<span class="hljs-keyword">if</span> (!navigateDfd.promise.isPending()) {
				logger.error(<span class="hljs-string">"Finished navigation after FAILSAFE_ROUTER_TIMEOUT"</span>, {
					page: context.page,
					path: req.path,
				});
				<span class="hljs-keyword">return</span>;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>Success.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			navigateDfd.resolve();

			<span class="hljs-keyword">if</span> (err) {</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>The page can elect to proceed to render
even with a non-2xx response.  If it
<em>doesn’t</em> do so then we’re done.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				<span class="hljs-keyword">var</span> done = !(page &amp;&amp; page.getHasDocument());

				<span class="hljs-keyword">if</span> (err.status === <span class="hljs-number">301</span> || err.status === <span class="hljs-number">302</span> || err.status === <span class="hljs-number">307</span>) {
					<span class="hljs-keyword">if</span> (done){</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>This adds a boilerplate body.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						res.redirect(err.status, err.redirectUrl);
					} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>This expects our page to
render a body.  Hope they
know what they’re doing.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>						res.set(<span class="hljs-string">'Location'</span>, err.redirectUrl);
					}
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (done) {
					<span class="hljs-keyword">if</span> (err.status === <span class="hljs-number">404</span>) {
						next();
					} <span class="hljs-keyword">else</span> {
						next(err);
					}
				}
				<span class="hljs-keyword">if</span> (done) {
					logger.log(<span class="hljs-string">"onNavigate received a non-2xx HTTP code"</span>, err);
					handleResponseComplete(req, res, context, start, page);
					<span class="hljs-keyword">return</span>;
				}
			}

			renderPage(req, res, context, start, page);

		});


		<span class="hljs-keyword">var</span> navigateDfd = Q.defer();

		<span class="hljs-keyword">const</span> timeout = setTimeout(navigateDfd.reject, FAILSAFE_ROUTER_TIMEOUT);</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Don’t leave dead timers hanging around.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		navigateDfd.promise.then(() =&gt; clearTimeout(timeout));</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>If we fail to navigate, we’ll throw a 500 and move on.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		navigateDfd.promise.catch(() =&gt; {
			logger.error(<span class="hljs-string">"Failed to navigate after FAILSAFE_ROUTER_TIMEOUT"</span>, {
				page: context.navigator.getCurrentRoute().name,
				path: req.path,
			});
			handleResponseComplete(req, res, context, start, context.page);
			next({status: <span class="hljs-number">500</span>});
		});

		context.navigate(<span class="hljs-keyword">new</span> ExpressServerRequest(req));

	})});
}

<span class="hljs-built_in">module</span>.exports.getActiveRequests = () =&gt; ACTIVE_REQUESTS;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initResponseCompletePromise</span>(<span class="hljs-params">res</span>)</span>{
	<span class="hljs-keyword">var</span> dfd = Q.defer();

	res.on(<span class="hljs-string">'close'</span>,  dfd.resolve);
	res.on(<span class="hljs-string">'finish'</span>, dfd.resolve);

	RLS().responseCompletePromise = dfd.promise;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleResponseComplete</span>(<span class="hljs-params">req, res, context, start, page</span>) </span>{

	RLS().responseCompletePromise.then(RequestLocalStorage.bind(() =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>All intentional response completion should funnel through
this function.  If this value starts climbing gradually
that’s an indication that we have some <em>unintentional</em>
response completion going on that we should deal with.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		ACTIVE_REQUESTS--;</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Note that if the navigator couldn’t even map the request to
a page, we won’t be able to call middleware
<code>handleComplete()</code> here.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (page) {
			logRequestStats(req, res, context, start, page);

			page.handleComplete();
		}
	}));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderPage</span>(<span class="hljs-params">req, res, context, start, page</span>) </span>{

	<span class="hljs-keyword">var</span> routeName = context.navigator.getCurrentRoute().name;

	logger.debug(<span class="hljs-string">"Route Name: "</span> + routeName);

	<span class="hljs-keyword">var</span> timer = logger.timer(<span class="hljs-string">"lifecycle.individual"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Protects some browsers (Chrome, IE) against MIME sniffing attacks.
see: <a href="http://security.stackexchange.com/a/12916">http://security.stackexchange.com/a/12916</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	res.set(<span class="hljs-string">'X-Content-Type-Options'</span>, <span class="hljs-string">'nosniff'</span>);

	res.status(page.getStatus()||<span class="hljs-number">200</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Each of these functions has the same signature and returns a
promise, so we can chain them up with a promise reduction.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> lifecycleMethods;
	<span class="hljs-keyword">if</span> (PageUtil.PageConfig.get(<span class="hljs-string">'isFragment'</span>)){
		lifecycleMethods = fragmentLifecycle();
	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (PageUtil.PageConfig.get(<span class="hljs-string">'isRawResponse'</span>)){
		lifecycleMethods = rawResponseLifecycle();
	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (req.query[ReactServerAgent.DATA_BUNDLE_PARAMETER]) {
		lifecycleMethods = dataBundleLifecycle();
	} <span class="hljs-keyword">else</span> {
		lifecycleMethods = pageLifecycle();
	}

	lifecycleMethods.reduce((chain, func) =&gt; chain
		.then(() =&gt; func(req, res, context, start, page))
		.then(() =&gt; {
			timer.tick(func.name);
			logger.time(<span class="hljs-string">`lifecycle.fromStart.<span class="hljs-subst">${func.name}</span>`</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> - start);
		})
	).catch(err =&gt; {
		logger.error(<span class="hljs-string">"Error in renderPage chain"</span>, err)</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>Register <code>finish</code> listener before ending response.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		handleResponseComplete(req, res, context, start, page);</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Bummer.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		res.status(<span class="hljs-number">500</span>).end();
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>TODO: we probably want a “we’re not waiting any longer for this”
timeout as well, and cancel the waiting deferreds</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rawResponseLifecycle</span> (<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">return</span> [
		Q(), <span class="hljs-comment">// NOOP lead-in to prime the reduction</span>
		setContentType,
		writeResponseData,
		handleResponseComplete,
		endResponse,
	];
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fragmentLifecycle</span> (<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">return</span> [
		Q(), <span class="hljs-comment">// NOOP lead-in to prime the reduction</span>
		setContentType,
		writeDebugComments,
		writeBody,
		handleResponseComplete,
		endResponse,
	];
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dataBundleLifecycle</span> (<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">return</span> [
		Q(), <span class="hljs-comment">// NOOP lead-in to prime the reduction</span>
		setDataBundleContentType,
		writeDataBundle,
		handleResponseComplete,
		endResponse,
	];
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pageLifecycle</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">return</span> [
		Q(), <span class="hljs-comment">// This is just a NOOP lead-in to prime the reduction.</span>
		setContentType,
		writeHeader,
		startBody,
		writeBody,
		wrapUpLateArrivals,
		closeBody,
		handleResponseComplete,
		endResponse,
	];
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setContentType</span>(<span class="hljs-params">req, res, context, start, pageObject</span>) </span>{
	res.set(<span class="hljs-string">'Content-Type'</span>, pageObject.getContentType());
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setDataBundleContentType</span>(<span class="hljs-params">req, res</span>) </span>{
	res.set(<span class="hljs-string">'Content-Type'</span>, <span class="hljs-string">'application/json'</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writeHeader</span>(<span class="hljs-params">req, res, context, start, pageObject</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>This is awkward and imprecise.  We don’t want to put <code>&lt;script&gt;</code>
tags between divs above the fold, so we’re going to keep separate
track of time client and server side. Then we’ll put <code>&lt;noscript&gt;</code>
tags with data elements representing offset from our <em>server</em> base
time that we’ll apply to our <em>client</em> base time as a proxy for when
the element arrived (when it’s actually when we <em>sent</em> it).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	RLS().timingDataT0 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>;

	res.type(<span class="hljs-string">'html'</span>);
	res.set(<span class="hljs-string">'Transfer-Encoding'</span>, <span class="hljs-string">'chunked'</span>);

	res.write(<span class="hljs-string">"&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>note: these responses can currently come back out-of-order, as many are returning
promises. scripts and stylesheets are guaranteed</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> Q.all([
		renderDebugComments(pageObject, res),
		renderTitle(pageObject, res),</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>PLAT-602: inline scripts come before stylesheets because
stylesheet downloads block inline script execution.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		renderScripts(pageObject, res),
		renderStylesheets(pageObject, res)
			.then(() =&gt; Q.all([
				renderMetaTags(pageObject, res),
				renderLinkTags(pageObject, res),
				renderBaseTag(pageObject, res),
			])),
	]).then(() =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>once we have finished rendering all of the pieces of the head element, we
can close the head and start the body element.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		res.write(<span class="hljs-string">`&lt;/head&gt;`</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Get headers out right away so secondary resource download can start.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		flushRes(res);
	});
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushRes</span>(<span class="hljs-params">res</span>)</span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>This method is only defined on the response object if the compress
middleware is installed, so we need to guard our calls.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (res.flush) {
		res.flush()
		<span class="hljs-keyword">if</span> (!RLS().didLogFirstFlush){
			RLS().didLogFirstFlush = <span class="hljs-literal">true</span>;
			logger.time(<span class="hljs-string">'firstFlush'</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> - RLS().startTime);
		}
	}
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderDebugComments</span> (<span class="hljs-params">pageObject, res</span>) </span>{
	<span class="hljs-keyword">var</span> debugComments = pageObject.getDebugComments();
	debugComments.map(debugComment =&gt; {
		<span class="hljs-keyword">if</span> (!debugComment.label || !debugComment.value) {
			logger.warning(<span class="hljs-string">"Debug comment is missing either a label or a value"</span>, debugComment);
		}

		res.write(<span class="hljs-string">`&lt;!-- <span class="hljs-subst">${debugComment.label}</span>: <span class="hljs-subst">${debugComment.value}</span> --&gt;`</span>);
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>resolve immediately.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> Q(<span class="hljs-string">""</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writeDebugComments</span> (<span class="hljs-params">req, res, context, start, pageObject</span>) </span>{
	<span class="hljs-keyword">return</span> Q(renderDebugComments(pageObject, res));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderTitle</span> (<span class="hljs-params">pageObject, res</span>) </span>{
	<span class="hljs-keyword">return</span> pageObject.getTitle().then((title) =&gt; {
		res.write(<span class="hljs-string">`&lt;title&gt;<span class="hljs-subst">${title}</span>&lt;/title&gt;`</span>);
	});
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">attrfy</span> (<span class="hljs-params">value</span>) </span>{
	<span class="hljs-keyword">return</span> value.replace(<span class="hljs-regexp">/"/g</span>, <span class="hljs-string">'&amp;quot;'</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderMetaTags</span> (<span class="hljs-params">pageObject, res</span>) </span>{
	<span class="hljs-keyword">var</span> metaTags = pageObject.getMetaTags();

	<span class="hljs-keyword">var</span> metaTagsRendered = metaTags.map(metaTagPromise =&gt; {
		<span class="hljs-keyword">return</span> metaTagPromise.then(PageUtil.makeArray).then(metaTags =&gt; metaTags.forEach(metaTag =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>TODO: escaping</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> ((metaTag.name &amp;&amp; metaTag.httpEquiv) || (metaTag.name &amp;&amp; metaTag.charset) || (metaTag.charset &amp;&amp; metaTag.httpEquiv)) {
				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Meta tag cannot have more than one of name, httpEquiv, and charset"</span>, metaTag);
			}

			<span class="hljs-keyword">if</span> ((metaTag.name &amp;&amp; !metaTag.content) || (metaTag.httpEquiv &amp;&amp; !metaTag.content)) {
				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Meta tag has name or httpEquiv but does not have content"</span>, metaTag);
			}

			<span class="hljs-keyword">if</span> (metaTag.noscript) res.write(<span class="hljs-string">`&lt;noscript&gt;`</span>);
			res.write(<span class="hljs-string">`&lt;meta`</span>);

			<span class="hljs-keyword">if</span> (metaTag.name)      res.write(<span class="hljs-string">` name="<span class="hljs-subst">${attrfy(metaTag.name)}</span>"`</span>);
			<span class="hljs-keyword">if</span> (metaTag.httpEquiv) res.write(<span class="hljs-string">` http-equiv="<span class="hljs-subst">${attrfy(metaTag.httpEquiv)}</span>"`</span>);
			<span class="hljs-keyword">if</span> (metaTag.charset)   res.write(<span class="hljs-string">` charset="<span class="hljs-subst">${attrfy(metaTag.charset)}</span>"`</span>);
			<span class="hljs-keyword">if</span> (metaTag.property)  res.write(<span class="hljs-string">` property="<span class="hljs-subst">${attrfy(metaTag.property)}</span>"`</span>);
			<span class="hljs-keyword">if</span> (metaTag.content)   res.write(<span class="hljs-string">` content="<span class="hljs-subst">${attrfy(metaTag.content)}</span>"`</span>);

			res.write(<span class="hljs-string">`&gt;`</span>)
			<span class="hljs-keyword">if</span> (metaTag.noscript) res.write(<span class="hljs-string">`&lt;/noscript&gt;`</span>);
		}));
	});

	<span class="hljs-keyword">return</span> Q.all(metaTagsRendered);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderLinkTags</span> (<span class="hljs-params">pageObject, res</span>) </span>{
	<span class="hljs-keyword">var</span> linkTags = pageObject.getLinkTags();

	<span class="hljs-keyword">var</span> linkTagsRendered = linkTags.map(linkTagPromise =&gt; {
		<span class="hljs-keyword">return</span> linkTagPromise.then(PageUtil.makeArray).then(linkTags =&gt; linkTags.forEach(linkTag =&gt; {

			<span class="hljs-keyword">if</span> (!linkTag.rel) {
				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`&lt;link&gt; tag specified without 'rel' attr`</span>);
			}

			res.write(<span class="hljs-string">`&lt;link <span class="hljs-subst">${PAGE_LINK_NODE_ID}</span> <span class="hljs-subst">${
				Object.keys(linkTag)
					.map(attr =&gt; `${attr}</span>="<span class="hljs-subst">${attrfy(linkTag[attr])}</span>"`</span>)
					.join(<span class="hljs-string">' '</span>)
			}&gt;<span class="hljs-string">`);
		}));
	});

	return Q.all(linkTagsRendered);
}

function renderBaseTag(pageObject, res) {
	return pageObject.getBase().then((base) =&gt; {
		if (base !== null) {
			if (!base.href &amp;&amp; !base.target) {
				throw new Error("&lt;base&gt; needs at least one of 'href' or 'target'");
			}
			var tag = "&lt;base";
			if (base.href) {
				tag += `</span> href=<span class="hljs-string">"${attrfy(base.href)}"</span><span class="hljs-string">`;
			}
			if (base.target) {
				tag += `</span> target=<span class="hljs-string">"${attrfy(base.target)}"</span><span class="hljs-string">`;
			}
			tag += "&gt;";
			res.write(tag);
		}
	});
}

function renderScriptsSync(scripts, res) {

</span></pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>right now, the getXXXScriptFiles methods return synchronously, no promises, so we can render
immediately.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	scripts.forEach( (script) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>make sure there’s a leading ‘/‘</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (!script.type) script.type = <span class="hljs-string">"text/javascript"</span>;

		<span class="hljs-keyword">if</span> (script.href) {
			res.write(<span class="hljs-string">`&lt;script src="<span class="hljs-subst">${script.href}</span>" type="<span class="hljs-subst">${script.type}</span>"&gt;&lt;/script&gt;`</span>);
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (script.text) {
			res.write(<span class="hljs-string">`&lt;script type="<span class="hljs-subst">${script.type}</span>"&gt;<span class="hljs-subst">${script.text}</span>&lt;/script&gt;`</span>);
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Script cannot be rendered because it has neither an href nor a text attribute: "</span> + script);
		}
	});
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderScriptsAsync</span>(<span class="hljs-params">scripts, res</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>Nothing to do if there are no scripts.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (!scripts.length) <span class="hljs-keyword">return</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>Don’t need “type” in <script> tags anymore.</p>
<p><a href="http://www.w3.org/TR/html/scripting-1.html#the-script-element">http://www.w3.org/TR/html/scripting-1.html#the-script-element</a></p>
<blockquote>
<p>The default, which is used if the attribute is absent, is “text/javascript”.</p>
</blockquote>

            </div>
            
            <div class="content"><div class='highlight'><pre>	res.write(<span class="hljs-string">"&lt;script&gt;"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Lazily load LAB the first time we spit out async scripts.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (!RLS().didLoadLAB){</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>This is the full implementation of LABjs.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		res.write(LABString);</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>We always want scripts to be executed in order.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		res.write(<span class="hljs-string">"$LAB.setGlobalDefaults({AlwaysPreserveOrder:true});"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>We’ll use this to store state between calls (see below).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		res.write(<span class="hljs-string">"window._tLAB=$LAB"</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>Only need to do this part once.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		RLS().didLoadLAB = <span class="hljs-literal">true</span>;
	} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>The assignment to <code>_tLAB</code> here is so we maintain a single
LAB chain through all of our calls to <code>renderScriptsAsync</code>.</p>
<p>Each call to this function emits output that looks
something like:</p>
<p>  _tLAB=_tLAB.script(…).wait(…) …</p>
<p>The result is that <code>window._tLAB</code> winds up holding the
final state of the LAB chain after each call, so that same
LAB chain can be appended to in the <em>next</em> call (if there
is one).</p>
<p>You can think of a LAB chain as being similar to a promise
chain.  The output of <code>$LAB.script()</code> or <code>$LAB.wait()</code> is
an object that itself has <code>script()</code> and <code>wait()</code> methods.
So long as the output of each call is used as the input for
the next call our code (both async loaded scripts and
inline JS) will be executed <em>in order</em>.</p>
<p>If we start a <em>new</em> chain directly from <code>$LAB</code> (the root
chain), we can wind up with <em>out of order</em> execution.</p>
<p>We want everything to be executed in order, so we maintain
one master chain for the page.  This chain is
<code>window._tLAB</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		res.write(<span class="hljs-string">"_tLAB=_tLAB"</span>);
	}

	scripts.forEach(script =&gt; {

		<span class="hljs-keyword">if</span> (script.href) {
			<span class="hljs-keyword">var</span> LABScript = { src: script.href };

			<span class="hljs-keyword">if</span> (script.crossOrigin){
				LABScript.crossOrigin = script.crossOrigin;
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>If we don’t have any other options we can shave a
few bytes by just passing the string.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.keys(LABScript).length === <span class="hljs-number">1</span>){
				LABScript = LABScript.src;
			}

			<span class="hljs-keyword">if</span> (script.condition) {
				res.write(<span class="hljs-string">`.script(function(){if(<span class="hljs-subst">${script.condition}</span>) return <span class="hljs-subst">${JSON.stringify(LABScript)}</span>})`</span>);
			} <span class="hljs-keyword">else</span> {
				res.write(<span class="hljs-string">`.script(<span class="hljs-subst">${JSON.stringify(LABScript)}</span>)`</span>);
			}

		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (script.text) {
			<span class="hljs-keyword">if</span> (script.condition) {
				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Script using `text` cannot be loaded conditionally"</span>);
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>The try/catch dance here is so exceptions get their
own time slice and can’t mess with execution of the
LAB chain.</p>
<p>The binding to <code>this</code> is so enclosed references to
<code>this</code> correctly get the <code>window</code> object (despite
being in a strict context).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			res.write(<span class="hljs-string">`.wait(function(){<span class="hljs-subst">${
				script.strict?'"use strict";':''
			}</span>try{<span class="hljs-subst">${
				script.text
			}</span>}catch(e){setTimeout(function(){throw(e)},1)}}.bind(this))`</span>);

		} <span class="hljs-keyword">else</span> {

			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Script needs either `href` or `text`: "</span> + script);
		}
	});

	res.write(<span class="hljs-string">";&lt;/script&gt;"</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderScripts</span>(<span class="hljs-params">pageObject, res</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Want to gather these into one list of scripts, because we care if
there are any non-JS scripts in the whole bunch.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> scripts = pageObject.getSystemScripts().concat(pageObject.getScripts());

	<span class="hljs-keyword">var</span> thereIsAtLeastOneNonJSScript = scripts.filter(
		script =&gt; script.type &amp;&amp; script.type !== <span class="hljs-string">"text/javascript"</span>
	).length;

	<span class="hljs-keyword">if</span> (thereIsAtLeastOneNonJSScript){</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>If there are non-JS scripts we can’t use LAB for async
loading.  We still want to preserve script execution order,
so we’ll cut over to all-synchronous loading.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		renderScriptsSync(scripts, res);
	} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>Otherwise, we can do async script loading.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		renderScriptsAsync(scripts, res);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>resolve immediately.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> Q(<span class="hljs-string">""</span>);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderStylesheets</span> (<span class="hljs-params">pageObject, res</span>) </span>{

	<span class="hljs-keyword">const</span> writeTag = styleSheet =&gt; {
		<span class="hljs-keyword">if</span> (!styleSheet) {</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>skip. a promise resolving to nothing is the only way to decide
to not output a stylesheet if you return a promise</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span>;
		}
		<span class="hljs-keyword">if</span> (styleSheet.href) {
			res.write(<span class="hljs-string">`&lt;link rel="stylesheet" type="<span class="hljs-subst">${styleSheet.type}</span>" media="<span class="hljs-subst">${styleSheet.media}</span>" href="<span class="hljs-subst">${styleSheet.href}</span>" <span class="hljs-subst">${PAGE_CSS_NODE_ID}</span>&gt;`</span>);
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (styleSheet.text) {
			res.write(<span class="hljs-string">`&lt;style type="<span class="hljs-subst">${styleSheet.type}</span>" media="<span class="hljs-subst">${styleSheet.media}</span>" <span class="hljs-subst">${PAGE_CSS_NODE_ID}</span>&gt;<span class="hljs-subst">${styleSheet.text}</span>&lt;/style&gt;`</span>);
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Style cannot be rendered because it has neither an href nor a text attribute: "</span> + styleSheet);
		}
	};

	<span class="hljs-keyword">const</span> styles = PageUtil.standardizeStyles(pageObject.getHeadStylesheets());

	<span class="hljs-keyword">return</span> styles.reduce( (prev, styleP) =&gt; {
		<span class="hljs-keyword">return</span> prev.then(() =&gt; styleP.then(writeTag));
	}, Q());
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">startBody</span>(<span class="hljs-params">req, res, context, start, page</span>) </span>{

	<span class="hljs-keyword">var</span> routeName = context.navigator.getCurrentRoute().name

	<span class="hljs-keyword">return</span> page.getBodyClasses().then((classes) =&gt; {
		classes.push(<span class="hljs-string">`route-<span class="hljs-subst">${routeName}</span>`</span>)
		res.write(<span class="hljs-string">`&lt;body class='<span class="hljs-subst">${classes.join(' ')}</span>'&gt;`</span>);
	}).then(() =&gt; page.getBodyStartContent()).then((texts) =&gt; texts.forEach((text) =&gt; {
		res.write(text);
	})).then(() =&gt; {
		res.write(<span class="hljs-string">`&lt;div id='content' <span class="hljs-subst">${PAGE_CONTENT_NODE_ID}</span>&gt;`</span>);
	});
}

<span class="hljs-comment">/**
 * Writes out the ReactElements to the response. Returns a promise that fulfills when
 * all the ReactElements have been written out.
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writeBody</span>(<span class="hljs-params">req, res, context, start, page</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>standardize to an array of EarlyPromises of ReactElements</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> elementPromises = PageUtil.standardizeElements(page.getElements());</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>This is where we’ll store our rendered HTML strings.  A value of
<code>undefined</code> means we haven’t rendered that element yet.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> rendered = elementPromises.map(() =&gt; ELEMENT_PENDING);</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>We need to return a promise that resolves when we’re done, so we’ll
maintain an array of deferreds that we punch out as we render
elements and we’ll return a promise that resolves when they’ve all
been hit.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> dfds = elementPromises.map(() =&gt; Q.defer());

	<span class="hljs-keyword">var</span> doElement = (element, index) =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>Exceeded <code>FAILSAFE_RENDER_TIMEOUT</code>.  Bummer.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (rendered[index] === ELEMENT_ALREADY_WRITTEN) <span class="hljs-keyword">return</span>;

		rendered[index] = renderElement(res, element, context);</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>If we’ve just rendered the next element to be written we’ll
write it out.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		writeElements(res, rendered);

		dfds[index].resolve();
	};</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>Render elements as their data becomes available.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	elementPromises.forEach((promise, index) =&gt; promise
		.then(element =&gt; doElement(element, index))
		.catch(e =&gt; {
			logger.error(<span class="hljs-string">`Error rendering element <span class="hljs-subst">${index}</span>`</span>, e)</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>TODO: the error handling here should probably be merged
somehow with renderElement so that we get timing info.</p>

            </div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>In the case where there was an exception thrown while rendering,
the next three lines are effectively a no-op. In the case where
the element promise was rejected, this prevents a hang until
FAILSAFE_RENDER_TIMEOUT has passed.</p>

            </div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>No way we can recover in the second case, so let’s just move on.
We’ll call <code>writeElements</code> just in case everything is ready
after us.</p>

            </div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>This doesn’t completely handle the extremely unlikely case that:
    1) <code>renderElement</code> successfully rendered this element, and
    2) <code>writeElements</code> successfully wrote it, but…
    3) <code>writeElements</code> threw after this element was written.</p>
<p>We’ll make a good-faith effort, but in this rare case writeElements is probably
going to fail again when we call it here. At least if that happens, <em>this</em>
particular element should show up properly on the page, even though the page
overall could be totally horked. And we won’t have a 20s timeout…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">try</span> {
				<span class="hljs-keyword">if</span> (rendered[index] !== ELEMENT_ALREADY_WRITTEN) {
					rendered[index] = <span class="hljs-string">''</span>;
					writeElements(res, rendered);
				}
			} <span class="hljs-keyword">finally</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>try <em>really</em> hard to resolve this deferred, to avoid a 20s hang.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				dfds[index].resolve();
			}
		})</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>just in case writeElements throws in our error callback above.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		.catch(e =&gt; logger.error(<span class="hljs-string">`Error recovering from error rendering element <span class="hljs-subst">${index}</span>`</span>, e))
	);</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>Some time has already elapsed since the request started.
Note that you can override <code>FAILSAFE_RENDER_TIMEOUT</code> with a
<code>?_debug_render_timeout={ms}</code> query string parameter.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> totalWait     = req.query._debug_render_timeout || FAILSAFE_RENDER_TIMEOUT
	,   timeRemaining = totalWait - (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> - start)

	<span class="hljs-keyword">var</span> retval = Q.defer();</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>If we exceed the timeout then we’ll just send empty elements for
anything that hadn’t rendered yet.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	retval.promise.catch(() =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>Write out what we’ve got.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		writeElements(res, rendered.map(
			value =&gt; value === ELEMENT_PENDING?<span class="hljs-string">''</span>:value
		));</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>If it hasn’t arrived by now, we’re not going to wait for it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		RLS().lateArrivals = <span class="hljs-literal">undefined</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>Let the client know it’s not getting any more data.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		renderScriptsAsync([{ text: <span class="hljs-string">`__reactServerClientController.failArrival()`</span> }], res)
	});

	Q.all(dfds.map(dfd =&gt; dfd.promise)).then(retval.resolve);

	<span class="hljs-keyword">const</span> timeout = setTimeout(() =&gt; {</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>give some additional information when we time out</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		retval.reject({
			message: <span class="hljs-string">"Timed out rendering."</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p><code>timeRemaining</code> is how long we waited before timing out</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			timeWaited: timeRemaining,
			elements: rendered.map(val =&gt; {
				<span class="hljs-keyword">if</span> (val === ELEMENT_ALREADY_WRITTEN) {
					<span class="hljs-keyword">return</span> <span class="hljs-string">'W'</span>; <span class="hljs-comment">// written</span>
				} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val === ELEMENT_PENDING) {
					<span class="hljs-keyword">return</span> <span class="hljs-string">'P'</span>; <span class="hljs-comment">// not rendered</span>
				} <span class="hljs-keyword">else</span> {
					<span class="hljs-keyword">return</span> <span class="hljs-string">'R'</span>; <span class="hljs-comment">// rendered, not yet written</span>
				}
			}),
		});
	}, timeRemaining);</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>Don’t leave dead timers hanging around.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	retval.promise.then(() =&gt; clearTimeout(timeout));

	<span class="hljs-keyword">return</span> retval.promise;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writeResponseData</span>(<span class="hljs-params">req, res, context, start, page</span>) </span>{
	page.setExpressRequest(req);
	page.setExpressResponse(res);
	<span class="hljs-keyword">return</span> page.getResponseData().then(data =&gt; {
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> data !== <span class="hljs-string">'undefined'</span>) {
			res.write(data);
		}
	});
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writeDataBundle</span>(<span class="hljs-params">req, res</span>) </span>{

	<span class="hljs-keyword">const</span> cache = ReactServerAgent.cache();

	<span class="hljs-keyword">return</span> Q.allSettled(
		cache.getPendingRequests().map(v =&gt; v.entry.dfd.promise)
	).then(() =&gt; res.write(<span class="hljs-built_in">JSON</span>.stringify(cache.dehydrate())));
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderElement</span>(<span class="hljs-params">res, element, context</span>) </span>{

	<span class="hljs-keyword">if</span> (element.containerOpen || element.containerClose || element.isTheFold){</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>Short-circuit out.  Don’t want timing for control objects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">return</span> element;
	}

	<span class="hljs-keyword">var</span> name  = PageUtil.getElementDisplayName(element)
	,   start = RLS().startTime
	,   timer = logger.timer(<span class="hljs-string">`renderElement.individual.<span class="hljs-subst">${name}</span>`</span>)
	,   html  = <span class="hljs-string">''</span>
	,   attrs = {}

	<span class="hljs-keyword">try</span> {
		<span class="hljs-keyword">if</span> (element !== <span class="hljs-literal">null</span>) {
			html = ReactDOMServer.renderToString(
				React.cloneElement(element, { context: context })
			);
			attrs = getRootElementAttributes(element);
		}
	} <span class="hljs-keyword">catch</span> (err) {</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>A component failing to render is not fatal.  We’ve already
started the page with a 200 response.  We’ve even opened
the <code>data-react-server-root-id</code> div for this component.  We need
to close it out and move on.  This is a bummer, and we’ll
log it, but it’s too late to totally bail out.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		logger.error(<span class="hljs-string">`Error rendering element <span class="hljs-subst">${name}</span>`</span>, err);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>We time how long <em>this</em> element’s render took, and also how long
since the beginning of the request it took us to spit this element
out.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> individualTime = timer.stop();
	logger.time(<span class="hljs-string">`renderElement.fromStart.<span class="hljs-subst">${name}</span>`</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> - start);</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>We <em>also</em> keep track of the <em>total</em> time we spent rendering during
each request so we can keep track of that overhead.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	RLS().renderTime || (RLS().renderTime = <span class="hljs-number">0</span>);
	RLS().renderTime += individualTime;

	<span class="hljs-keyword">return</span> { html, attrs };
}</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>Write as many elements out in a row as possible and then flush output.
We render elements as their data becomes available, so they might fill in
out-of-order.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writeElements</span>(<span class="hljs-params">res, elements</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>Pick up where we left off.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> start = RLS().nextElement||(RLS().nextElement=<span class="hljs-number">0</span>);

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = start; i &lt; elements.length; RLS().nextElement = ++i){</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>If we haven’t rendered the next element yet, we’re done.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> (elements[i] === ELEMENT_PENDING) <span class="hljs-keyword">break</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>Got one!</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		writeElement(res, elements[i], i);</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>Free for GC.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		elements[i] = ELEMENT_ALREADY_WRITTEN;

		<span class="hljs-keyword">if</span> (PageUtil.PageConfig.get(<span class="hljs-string">'isFragment'</span>)) <span class="hljs-keyword">continue</span>;

		<span class="hljs-keyword">if</span> (RLS().haveBootstrapped) {</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>We’ve already bootstrapped, so we can immediately tell the
client controller to wake the new element we just sent.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			wakeElementRange(res, i, i);
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i === elements.length - <span class="hljs-number">1</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>Page didn’t emit <code>&lt;TheFold/&gt;</code>.  Now we’re done.
This wakes everything up through <code>i</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			bootstrapClient(res, i);
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p>It may be a while before we render the next element, so if we just
wrote anything let’s send it down right away.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (i !== start) flushRes(res);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">writeElement</span>(<span class="hljs-params">res, element, i</span>)</span>{
	<span class="hljs-keyword">if</span> (!element) {</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p>A falsy element was a render error.  We’ve gotta
emit a root for it, so we’ll cook up an empty
element object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		element = {
			attrs : {},
			html  : <span class="hljs-string">''</span>,
		}
	}
	<span class="hljs-keyword">if</span> (element.containerOpen) {
		res.write(<span class="hljs-string">`&lt;div <span class="hljs-subst">${PAGE_CONTAINER_NODE_ID}</span>=<span class="hljs-subst">${i}</span><span class="hljs-subst">${
			_.map(element.containerOpen, (v, k) =&gt; ` ${k}</span>="<span class="hljs-subst">${attrfy(v)}</span>"`</span>)
		}&gt;<span class="hljs-string">`);
	} else if (element.containerClose) {
		res.write('&lt;/div&gt;');
	} else if (element.isTheFold) {

</span></pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>Okay, we’ve sent all of our above-the-fold HTML,
now we can let the client start waking nodes up.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		bootstrapClient(res, i)
	} <span class="hljs-keyword">else</span> {
		res.write(<span class="hljs-string">`&lt;div data-react-server-root-id=<span class="hljs-subst">${
			i
		}</span> data-react-server-timing-offset="<span class="hljs-subst">${
</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>Mark when we sent it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			new Date - RLS().timingDataT0
		}"${
			_.map(element.attrs, (v, k) =&gt; ` ${k}="${attrfy(v)}"`)
		}&gt;${element.html}&lt;/div&gt;`);
	}
}

function logAboveTheFoldTime(res) {</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>write a synchronous script to record the time on the browser when above the fold content shows up
this is a proxy for “first paint” when the DOM is parsed and painted</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	renderScriptsSync([{text:<span class="hljs-string">'__displayAboveTheFold=new Date;'</span> +
		<span class="hljs-string">'window.performance &amp;&amp; window.performance.mark &amp;&amp; window.performance.mark("displayAboveTheFold.fromStart");'</span>}], res);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bootstrapClient</span>(<span class="hljs-params">res, lastElementSent</span>) </span>{

	logAboveTheFoldTime(res);

	<span class="hljs-keyword">var</span> initialContext = {
		<span class="hljs-string">'ReactServerAgent.cache'</span>: ReactServerAgent.cache().dehydrate(),
	};

	res.expose(initialContext, <span class="hljs-string">'InitialContext'</span>);
	res.expose(getNonInternalConfigs(), <span class="hljs-string">"Config"</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>Using naked <code>rfBootstrap()</code> instead of <code>window.rfBootstrap()</code>
because the browser’s error message if it isn’t defined is more
helpful this way.  With <code>window.rfBootstrap()</code> the error is just
“undefined is not a function”.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	renderScriptsAsync([{
		text: <span class="hljs-string">`<span class="hljs-subst">${res.locals.state}</span>;rfBootstrap();`</span>,
	}], res);</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>This actually needs to happen <em>synchronously</em> with this current
function to avoid letting responses slip in between.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	setupLateArrivals(res);

	wakeElementRange(res, <span class="hljs-number">0</span>, lastElementSent);

	RLS().haveBootstrapped = <span class="hljs-literal">true</span>;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wakeElementRange</span>(<span class="hljs-params">res, startIndex, endIndex</span>) </span>{
	endIndex = endIndex || startIndex;
	renderScriptsAsync([{
		text: <span class="hljs-string">`__reactServerClientController.nodeArrival(<span class="hljs-subst">${startIndex}</span>,<span class="hljs-subst">${endIndex}</span>)`</span>,
	}], res);
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setupLateArrivals</span>(<span class="hljs-params">res</span>) </span>{
	<span class="hljs-keyword">var</span> start = RLS().startTime;
	<span class="hljs-keyword">var</span> notLoaded = ReactServerAgent.cache().getPendingRequests();</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>This is for reporting purposes.  We’re going to log how many late
requests there were, but we won’t actually emit the log line until
all of the requests have resolved.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	ReactServerAgent.cache().markLateRequests();

	notLoaded.forEach( pendingRequest =&gt; {
		pendingRequest.entry.whenDataReadyInternal().then( () =&gt; {
			logger.time(<span class="hljs-string">"lateArrival"</span>, <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> - start);
			renderScriptsAsync([{
				text: <span class="hljs-string">`__reactServerClientController.dataArrival(<span class="hljs-subst">${
					JSON.stringify(pendingRequest.url)
				}</span>, <span class="hljs-subst">${
					StringEscapeUtil.escapeForScriptTag(JSON.stringify(pendingRequest.entry.dehydrate()))
				}</span>);`</span>,
			}], res);

		})
	});</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p>TODO: maximum-wait-time-exceeded-so-cancel-pending-requests code</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> promises = notLoaded.map( result =&gt; result.entry.dfd.promise );
	RLS().lateArrivals = Q.allSettled(promises)
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrapUpLateArrivals</span>(<span class="hljs-params"></span>)</span>{
	<span class="hljs-keyword">return</span> RLS().lateArrivals;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">closeBody</span>(<span class="hljs-params">req, res</span>) </span>{
	res.write(<span class="hljs-string">"&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;"</span>);
	<span class="hljs-keyword">return</span> Q();
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">endResponse</span>(<span class="hljs-params">req, res</span>) </span>{
	res.end();
	<span class="hljs-keyword">return</span> Q();
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logRequestStats</span>(<span class="hljs-params">req, res, context, start</span>)</span>{
	<span class="hljs-keyword">var</span> allRequests = ReactServerAgent.cache().getAllRequests()
	,   notLoaded   = ReactServerAgent.cache().getLateRequests()
	,   sock        = req.socket
	,   stash       = context.getServerStash()</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>The socket can be re-used for multiple requests with keep-alive.
Fortunately, until HTTP/2 rolls around, the requests over a given
socket will happen serially.  So we can just keep track of the
previous values for each socket and log the delta for a given
request.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	stash.bytesR = sock.bytesRead    - (sock._preR||(sock._preR=<span class="hljs-number">0</span>));
	stash.bytesW = sock.bytesWritten - (sock._preW||(sock._preW=<span class="hljs-number">0</span>));

	sock._preR += stash.bytesR;
	sock._preW += stash.bytesW;

	logger.gauge(<span class="hljs-string">"countDataRequests"</span>, allRequests.length);
	logger.gauge(<span class="hljs-string">"countLateArrivals"</span>, notLoaded.length, {hi: <span class="hljs-number">1</span>});
	logger.gauge(<span class="hljs-string">"bytesRead"</span>, stash.bytesR, {hi: <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">12</span>});
	logger.gauge(<span class="hljs-string">"bytesWritten"</span>, stash.bytesW, {hi: <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">18</span>});

	<span class="hljs-keyword">var</span> time = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> - start;

	logger.time(<span class="hljs-string">`responseCode.<span class="hljs-subst">${res.statusCode}</span>`</span>, time);
	logger.time(<span class="hljs-string">"totalRequestTime"</span>, time);</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>Only populated for full pages and fragments.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (RLS().renderTime){
		logger.time(<span class="hljs-string">"totalRenderTime"</span>, RLS().renderTime);
	}

	<span class="hljs-keyword">if</span> (notLoaded.length) {
		logger.time(<span class="hljs-string">"totalRequestTimeWithLateArrivals"</span>, time);
	}

	<span class="hljs-keyword">return</span> Q();
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNonInternalConfigs</span>(<span class="hljs-params"></span>) </span>{
	<span class="hljs-keyword">var</span> nonInternal = {};
	<span class="hljs-keyword">var</span> fullConfig = config();
	<span class="hljs-built_in">Object</span>.keys(fullConfig).forEach( configKey =&gt; {
		<span class="hljs-keyword">if</span> (configKey !== <span class="hljs-string">'internal'</span>) {
			nonInternal[configKey] = fullConfig[configKey];
		}
	});
	<span class="hljs-keyword">return</span> nonInternal;
}</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
